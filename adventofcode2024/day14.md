# Day 14

## Part 1

Ok, so here is the puzzle: https://adventofcode.com/2024/day/14

My first idea is to do some modulo calculations because the drones "wrap around" the space so that means I think that we can use modular arithmetic to just calculate the positions in one go instead of having to simulate each step separately... let's try it out...

## The plan

Ok, so here is my plan handwritten:




So basically just calculate the position vector which is just `p = p0 ' v*t` where p0 is the initial position and v is the velocity vector and t is time which in the puzzle is 100.

Ok, so here is my initial parsing function:

```

import re
import sys

def simulate_drones(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])

	print(drones)
	return 0

def solve() -> int:

	if len(sys.argv) != 2:
		print("Usage: python "+str(sys.argv[0])+" INPUTFILE")
		return 1

	fh = open(sys.argv[1], "r")
	lines = fh.readlines()
	fh.close()

	sol = simulate_drones(lines)
	print("Solution: "+str(sol))
	return 0

if __name__=="__main__":

	ret = solve()

	exit(ret)

```

Now let's create a function which returns the position after t amount of time steps.


Something like this maybe???

```

def go_forward_in_time(p0, v, t): # This function returns the position after t timesteps.
	# Basically just p = p0 + v*t
	assert isinstance(t, int) # Timestep should be discrete integer.
	return (p0[0] + v[0]*t, p0[1] + v[1]*t)

MAP_HEIGHT = 103
MAP_WIDTH = 101

MAP_WIDTH_MIDDLE = 50
MAP_HEIGHT_MIDDLE = 51

MIDDLE_CROSS = 0 # This is when we are in the boundary between quadrants. These do not count towards the total score.
BOTTOM_RIGHT = 1
BOTTOM_LEFT = 2
TOP_RIGHT = 3
TOP_LEFT = 4

def clamp_positions(positions):
	# So the position is basically just (x % width, y % height)
	return [(x[0] % MAP_WIDTH, x[1] % MAP_HEIGHT) for x in positions]

def quadrant(position): # Returns the quadrant thing. 0 means that it is in the middle cross which doesn't accumulate score.
	x = position[0]
	y = position[1]
	if x > MAP_WIDTH_MIDDLE: # On the right side.
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom right.
			return BOTTOM_RIGHT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top right
			return TOP_RIGHT
		else: # Boundary.
			return MIDDLE_CROSS
	elif x < MAP_WIDTH_MIDDLE:
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom left.
			return BOTTOM_LEFT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top left
			return TOP_LEFT
		else: # Boundary.
			return MIDDLE_CROSS
	else: # On the boundary
		return MIDDLE_CROSS
	assert False

def calc_safety_score(positions):


def simulate_drones(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])

	new_positions = [go_forward_in_time(x[0], x[1]) for x in drones] # Go forward in time.
	clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

	# Calculate safety score:

	safety_score = calc_safety_score(clamped_positions)

	return 0

```

it basically just simulates time forward and then figures out the landing place with modular arithmetic. to calculate the safety score, just "bucket" the quadrants and then multiple all of them (except the boundary) together.

Here is my current code:

```


import re
import sys


def go_forward_in_time(p0, v, t): # This function returns the position after t timesteps.
	# Basically just p = p0 + v*t
	assert isinstance(t, int) # Timestep should be discrete integer.
	return (p0[0] + v[0]*t, p0[1] + v[1]*t)

MAP_HEIGHT = 103
MAP_WIDTH = 101

MAP_WIDTH_MIDDLE = 50
MAP_HEIGHT_MIDDLE = 51

MIDDLE_CROSS = 0 # This is when we are in the boundary between quadrants. These do not count towards the total score.
BOTTOM_RIGHT = 1
BOTTOM_LEFT = 2
TOP_RIGHT = 3
TOP_LEFT = 4
TIMESTEPS = 100

def clamp_positions(positions):
	# So the position is basically just (x % width, y % height)
	return [(x[0] % MAP_WIDTH, x[1] % MAP_HEIGHT) for x in positions]

def quadrant(position): # Returns the quadrant thing. 0 means that it is in the middle cross which doesn't accumulate score.
	x = position[0]
	y = position[1]
	if x > MAP_WIDTH_MIDDLE: # On the right side.
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom right.
			return BOTTOM_RIGHT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top right
			return TOP_RIGHT
		else: # Boundary.
			return MIDDLE_CROSS
	elif x < MAP_WIDTH_MIDDLE:
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom left.
			return BOTTOM_LEFT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top left
			return TOP_LEFT
		else: # Boundary.
			return MIDDLE_CROSS
	else: # On the boundary
		return MIDDLE_CROSS
	assert False

def calc_safety_score(positions):
	quadrant_buckets = [0,0,0,0,0] # The first one is basically the cross boundary so it doesn't count towards the total.
	for pos in positions:
		q = quadrant(pos)
		assert q in list(range(5))
		quadrant_buckets[q] += 1
	return quadrant_buckets[1]*quadrant_buckets[2]*quadrant_buckets[3]*quadrant_buckets[4]

def simulate_drones(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])

	new_positions = [go_forward_in_time(x[0], x[1], TIMESTEPS) for x in drones] # Go forward in time.
	clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

	# Calculate safety score:

	safety_score = calc_safety_score(clamped_positions)

	return safety_score

def solve() -> int:

	if len(sys.argv) != 2:
		print("Usage: python "+str(sys.argv[0])+" INPUTFILE")
		return 1

	fh = open(sys.argv[1], "r")
	lines = fh.readlines()
	fh.close()

	sol = simulate_drones(lines)
	print("Solution: "+str(sol))
	return 0

if __name__=="__main__":

	ret = solve()

	exit(ret)


```


Let's try it out. Except let's try with the toy example first...


Like so:


```


import re
import sys

TEST = True

def go_forward_in_time(p0, v, t): # This function returns the position after t timesteps.
	# Basically just p = p0 + v*t
	assert isinstance(t, int) # Timestep should be discrete integer.
	return (p0[0] + v[0]*t, p0[1] + v[1]*t)

if TEST:
	MAP_HEIGHT = 7
	MAP_WIDTH = 11

	MAP_WIDTH_MIDDLE = 5
	MAP_HEIGHT_MIDDLE = 4

else:
	MAP_HEIGHT = 103
	MAP_WIDTH = 101

	MAP_WIDTH_MIDDLE = 50
	MAP_HEIGHT_MIDDLE = 51

MIDDLE_CROSS = 0 # This is when we are in the boundary between quadrants. These do not count towards the total score.
BOTTOM_RIGHT = 1
BOTTOM_LEFT = 2
TOP_RIGHT = 3
TOP_LEFT = 4
TIMESTEPS = 100

def clamp_positions(positions):
	# So the position is basically just (x % width, y % height)
	return [(x[0] % MAP_WIDTH, x[1] % MAP_HEIGHT) for x in positions]

def quadrant(position): # Returns the quadrant thing. 0 means that it is in the middle cross which doesn't accumulate score.
	x = position[0]
	y = position[1]
	if x > MAP_WIDTH_MIDDLE: # On the right side.
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom right.
			return BOTTOM_RIGHT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top right
			return TOP_RIGHT
		else: # Boundary.
			return MIDDLE_CROSS
	elif x < MAP_WIDTH_MIDDLE:
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom left.
			return BOTTOM_LEFT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top left
			return TOP_LEFT
		else: # Boundary.
			return MIDDLE_CROSS
	else: # On the boundary
		return MIDDLE_CROSS
	assert False

def calc_safety_score(positions):
	quadrant_buckets = [0,0,0,0,0] # The first one is basically the cross boundary so it doesn't count towards the total.
	for pos in positions:
		q = quadrant(pos)
		assert q in list(range(5))
		quadrant_buckets[q] += 1
	return quadrant_buckets[1]*quadrant_buckets[2]*quadrant_buckets[3]*quadrant_buckets[4]

def simulate_drones(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])

	new_positions = [go_forward_in_time(x[0], x[1], TIMESTEPS) for x in drones] # Go forward in time.
	clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

	# Calculate safety score:

	safety_score = calc_safety_score(clamped_positions)

	return safety_score

def solve() -> int:

	if len(sys.argv) != 2:
		print("Usage: python "+str(sys.argv[0])+" INPUTFILE")
		return 1

	fh = open(sys.argv[1], "r")
	lines = fh.readlines()
	fh.close()

	sol = simulate_drones(lines)
	print("Solution: "+str(sol))
	return 0

if __name__=="__main__":

	ret = solve()

	exit(ret)


```


but it doesn't work:

```
Solution: 36
```

## Debugging

Let's just make a render function which shows the places.

Here is my code:

```


import re
import sys
import copy

TEST = True

def go_forward_in_time(p0, v, t): # This function returns the position after t timesteps.
	# Basically just p = p0 + v*t
	assert isinstance(t, int) # Timestep should be discrete integer.
	return (p0[0] + v[0]*t, p0[1] + v[1]*t)

if TEST:
	MAP_HEIGHT = 7
	MAP_WIDTH = 11

	MAP_WIDTH_MIDDLE = 5
	MAP_HEIGHT_MIDDLE = 4

else:
	MAP_HEIGHT = 103
	MAP_WIDTH = 101

	MAP_WIDTH_MIDDLE = 50
	MAP_HEIGHT_MIDDLE = 51

MIDDLE_CROSS = 0 # This is when we are in the boundary between quadrants. These do not count towards the total score.
BOTTOM_RIGHT = 1
BOTTOM_LEFT = 2
TOP_RIGHT = 3
TOP_LEFT = 4
TIMESTEPS = 100

def clamp_positions(positions):
	# So the position is basically just (x % width, y % height)
	return [(x[0] % MAP_WIDTH, x[1] % MAP_HEIGHT) for x in positions]

def quadrant(position): # Returns the quadrant thing. 0 means that it is in the middle cross which doesn't accumulate score.
	x = position[0]
	y = position[1]
	if x > MAP_WIDTH_MIDDLE: # On the right side.
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom right.
			return BOTTOM_RIGHT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top right
			return TOP_RIGHT
		else: # Boundary.
			return MIDDLE_CROSS
	elif x < MAP_WIDTH_MIDDLE:
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom left.
			return BOTTOM_LEFT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top left
			return TOP_LEFT
		else: # Boundary.
			return MIDDLE_CROSS
	else: # On the boundary
		return MIDDLE_CROSS
	assert False

def calc_safety_score(positions):
	quadrant_buckets = [0,0,0,0,0] # The first one is basically the cross boundary so it doesn't count towards the total.
	for pos in positions:
		q = quadrant(pos)
		assert q in list(range(5))
		quadrant_buckets[q] += 1
	return quadrant_buckets[1]*quadrant_buckets[2]*quadrant_buckets[3]*quadrant_buckets[4]

def render_matrix(matrix):
	print(matrix)
	for line in matrix:
		for char in line:
			if char != 0:
				assert char < 10 # If more than ten then this fucks up the showing.
				print(str(char), end="")
			else:
				print(".", end="")
		print("\n", end="")
	return

def render_drones(drones):
	# Shows all of the timesteps.
	new_positions = copy.deepcopy(drones)
	for i in range(TIMESTEPS):
		new_positions = [go_forward_in_time(x[0], x[1], i) for x in drones] # Go forward in time.
		clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

		show_matrix = [[0 for _ in range(MAP_WIDTH)] for _ in range(MAP_HEIGHT)]

		# Now just put all of the stuff.
		for pos in clamped_positions:
			show_matrix[pos[1]][pos[0]] += 1

		render_matrix(show_matrix)

	return

def simulate_drones(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])


	render_drones(copy.deepcopy(drones))

	new_positions = [go_forward_in_time(x[0], x[1], TIMESTEPS) for x in drones] # Go forward in time.
	clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

	# Calculate safety score:

	safety_score = calc_safety_score(clamped_positions)

	return safety_score

def solve() -> int:

	if len(sys.argv) != 2:
		print("Usage: python "+str(sys.argv[0])+" INPUTFILE")
		return 1

	fh = open(sys.argv[1], "r")
	lines = fh.readlines()
	fh.close()

	sol = simulate_drones(lines)
	print("Solution: "+str(sol))
	return 0

if __name__=="__main__":

	ret = solve()

	exit(ret)


```

and here is the output with `p=2,4 v=2,-3`:

```
==============================
...........
...........
...........
...........
..1........
...........
...........
==============================
==============================
...........
....1......
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
......1....
...........
==============================
==============================
...........
...........
........1..
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
..........1
==============================
==============================
...........
...........
...........
.1.........
...........
...........
...........
==============================
==============================
...1.......
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
.....1.....
...........
...........
==============================
==============================
...........
.......1...
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
.........1.
...........
==============================
==============================
...........
...........
1..........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
..1........
==============================
==============================
...........
...........
...........
....1......
...........
...........
...........
==============================
==============================
......1....
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
........1..
...........
...........
==============================
==============================
...........
..........1
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
.1.........
...........
==============================
==============================
...........
...........
...1.......
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
.....1.....
==============================
==============================
...........
...........
...........
.......1...
...........
...........
...........
==============================
==============================
.........1.
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
1..........
...........
...........
==============================
==============================
...........
..1........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
....1......
...........
==============================
==============================
...........
...........
......1....
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
........1..
==============================
==============================
...........
...........
...........
..........1
...........
...........
...........
==============================
==============================
.1.........
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...1.......
...........
...........
==============================
==============================
...........
.....1.....
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
.......1...
...........
==============================
==============================
...........
...........
.........1.
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
1..........
==============================
==============================
...........
...........
...........
..1........
...........
...........
...........
==============================
==============================
....1......
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
......1....
...........
...........
==============================
==============================
...........
........1..
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
..........1
...........
==============================
==============================
...........
...........
.1.........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
...1.......
==============================
==============================
...........
...........
...........
.....1.....
...........
...........
...........
==============================
==============================
.......1...
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
.........1.
...........
...........
==============================
==============================
...........
1..........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
..1........
...........
==============================
==============================
...........
...........
....1......
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
......1....
==============================
==============================
...........
...........
...........
........1..
...........
...........
...........
==============================
==============================
..........1
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
.1.........
...........
...........
==============================
==============================
...........
...1.......
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
.....1.....
...........
==============================
==============================
...........
...........
.......1...
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
.........1.
==============================
==============================
...........
...........
...........
1..........
...........
...........
...........
==============================
==============================
..1........
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
....1......
...........
...........
==============================
==============================
...........
......1....
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
........1..
...........
==============================
==============================
...........
...........
..........1
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
.1.........
==============================
==============================
...........
...........
...........
...1.......
...........
...........
...........
==============================
==============================
.....1.....
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
.......1...
...........
...........
==============================
==============================
...........
.........1.
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
1..........
...........
==============================
==============================
...........
...........
..1........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
....1......
==============================
==============================
...........
...........
...........
......1....
...........
...........
...........
==============================
==============================
........1..
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
..........1
...........
...........
==============================
==============================
...........
.1.........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...1.......
...........
==============================
==============================
...........
...........
.....1.....
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
.......1...
==============================
==============================
...........
...........
...........
.........1.
...........
...........
...........
==============================
==============================
1..........
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
..1........
...........
...........
==============================
==============================
...........
....1......
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
......1....
...........
==============================
==============================
...........
...........
........1..
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
..........1
==============================
==============================
...........
...........
...........
.1.........
...........
...........
...........
==============================
==============================
...1.......
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
.....1.....
...........
...........
==============================
==============================
...........
.......1...
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
.........1.
...........
==============================
==============================
...........
...........
1..........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
..1........
==============================
==============================
...........
...........
...........
....1......
...........
...........
...........
==============================
==============================
......1....
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
........1..
...........
...........
==============================
==============================
...........
..........1
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
.1.........
...........
==============================
==============================
...........
...........
...1.......
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
...........
...........
.....1.....
==============================
==============================
...........
...........
...........
.......1...
...........
...........
...........
==============================
==============================
.........1.
...........
...........
...........
...........
...........
...........
==============================
==============================
...........
...........
...........
...........
1..........
...........
...........
==============================
==============================
...........
..1........
...........
...........
...........
...........
...........
==============================
```

So what is going on???

Now running with the given toy input, we can see that we actually get the correct answer with t=23:

```
..1......1.
==============================
T = 23
==============================
......2..1.
...........
1..........
.11........
.....1.....
...12......
.1....1....
==============================
T = 24
==============================
```

So maybe it has something to do with the time shit???

Ok, so yeah if we advance one time step at a time and clamp the position on every time step we get the correct answer with this:

```

def render_drones(drones):
	# Shows all of the timesteps.
	new_positions = copy.deepcopy(drones)
	for i in range(TIMESTEPS):
		print("T = "+str(i))
		new_positions = [[go_forward_in_time(x[0], x[1], 1), x[1]] for x in new_positions] # Go forward in time.
		clamped_positions = clamp_positions([x[0] for x in new_positions]) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

		show_matrix = [[0 for _ in range(MAP_WIDTH)] for _ in range(MAP_HEIGHT)]

		# Now just put all of the stuff.
		for pos in clamped_positions:
			show_matrix[pos[1]][pos[0]] += 1

		render_matrix(show_matrix)

	return

```

so we basically have a situation where the clamping produces different answers depending on if we advance just one step at a time or many steps. How is this possible? Let's write a quick checking function...

Here is my fuzzer:

```


from day14 import * # Import the solution which to test.

import random

MIN_POS_X = 0
MAX_POS_X = MAP_WIDTH

MIN_POS_Y = 0
MAX_POS_Y = MAP_HEIGHT




MIN_VEL_X = -100
MAX_VEL_X = 100

MIN_VEL_Y = -100
MAX_VEL_Y = 100


TEST_COUNT = 1000

TIMESTEPS = 100

def test_clamp():
	for i in range(TEST_COUNT):
		# Generate random drone.
		rand_drone_thing = [[(random.randrange(MIN_POS_X, MAX_POS_X), random.randrange(MIN_POS_Y, MAX_POS_Y)), (random.randrange(MIN_VEL_X, MAX_VEL_X), random.randrange(MIN_VEL_Y, MAX_VEL_Y))]]

		# Now see if the thing differs
		# First get the result of a one go thing.
		one_go_res = go_forward_and_clamp(rand_drone_thing, TIMESTEPS)[0]
		one_go_res = [one_go_res, rand_drone_thing[0][1]]
		# Go one step at a time.
		cur_pos = rand_drone_thing[0][0]
		for i in range(TIMESTEPS):
			cur_pos = go_forward_and_clamp([[cur_pos, rand_drone_thing[0][1]]], 1)[0]

		# Now check to see any difference.
		if [cur_pos, rand_drone_thing[0][1]] != one_go_res:
			print("Found discrepency with these parameters:")
			print("p0: "+str(rand_drone_thing[0][0]))
			print("v: "+str(rand_drone_thing[0][1]))
			print("One go thing: "+str(one_go_res))
			print("Incremental: "+str([cur_pos, rand_drone_thing[0][1]]))
			assert False
		print("Passed one test case!")
	print("Passed!")
	return


if __name__=="__main__":
	test_clamp()
	exit(0)

```

Except that it doesn't find anything.

Wait...

```


import re
import sys
import copy

TEST = True

def go_forward_in_time(p0, v, t): # This function returns the position after t timesteps.
	# Basically just p = p0 + v*t
	assert isinstance(t, int) # Timestep should be discrete integer.
	return (p0[0] + v[0]*t, p0[1] + v[1]*t)

if TEST:
	MAP_HEIGHT = 7
	MAP_WIDTH = 11

	MAP_WIDTH_MIDDLE = 5
	MAP_HEIGHT_MIDDLE = 4

else:
	MAP_HEIGHT = 103
	MAP_WIDTH = 101

	MAP_WIDTH_MIDDLE = 50
	MAP_HEIGHT_MIDDLE = 51

MIDDLE_CROSS = 0 # This is when we are in the boundary between quadrants. These do not count towards the total score.
BOTTOM_RIGHT = 1
BOTTOM_LEFT = 2
TOP_RIGHT = 3
TOP_LEFT = 4
TIMESTEPS = 100

def clamp_positions(positions):
	# So the position is basically just (x % width, y % height)
	return [(x[0] % MAP_WIDTH, x[1] % MAP_HEIGHT) for x in positions]

def quadrant(position): # Returns the quadrant thing. 0 means that it is in the middle cross which doesn't accumulate score.
	x = position[0]
	y = position[1]
	if x > MAP_WIDTH_MIDDLE: # On the right side.
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom right.
			return BOTTOM_RIGHT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top right
			return TOP_RIGHT
		else: # Boundary.
			return MIDDLE_CROSS
	elif x < MAP_WIDTH_MIDDLE:
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom left.
			return BOTTOM_LEFT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top left
			return TOP_LEFT
		else: # Boundary.
			return MIDDLE_CROSS
	else: # On the boundary
		return MIDDLE_CROSS
	assert False

def calc_safety_score(positions):
	quadrant_buckets = [0,0,0,0,0] # The first one is basically the cross boundary so it doesn't count towards the total.
	for pos in positions:
		q = quadrant(pos)
		assert q in list(range(5))
		quadrant_buckets[q] += 1
	return quadrant_buckets[1]*quadrant_buckets[2]*quadrant_buckets[3]*quadrant_buckets[4]

def render_matrix(matrix):
	#print(matrix)
	print("="*30)
	for line in matrix:
		for char in line:
			if char != 0:
				assert char < 10 # If more than ten then this fucks up the showing.
				print(str(char), end="")
			else:
				print(".", end="")
		print("\n", end="")
	print("="*30)
	return

def go_forward_and_clamp(drones, t):
	new_positions = [[go_forward_in_time(x[0], x[1], t), x[1]] for x in drones] # Go forward in time.
	clamped_positions = clamp_positions([x[0] for x in new_positions]) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.
	return clamped_positions


def show_positions(positions): # This takes in the clamped positions...
	show_matrix = [[0 for _ in range(MAP_WIDTH)] for _ in range(MAP_HEIGHT)]

	# Now just put all of the stuff.
	for pos in positions:
		show_matrix[pos[1]][pos[0]] += 1

	render_matrix(show_matrix)

	return

def render_drones(drones):
	# Shows all of the timesteps.
	new_positions = copy.deepcopy(drones)
	for i in range(TIMESTEPS):
		print("T = "+str(i))
		new_positions = [[go_forward_in_time(x[0], x[1], 1), x[1]] for x in new_positions] # Go forward in time.
		clamped_positions = clamp_positions([x[0] for x in new_positions]) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

		show_positions(clamped_positions)

	return

def simulate_drones(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])


	render_drones(copy.deepcopy(drones))

	new_positions = [go_forward_in_time(x[0], x[1], TIMESTEPS) for x in drones] # Go forward in time.
	clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

	# Calculate safety score:
	print("Our shit:")
	show_positions(clamped_positions)
	safety_score = calc_safety_score(clamped_positions)

	return safety_score

def solve() -> int:

	if len(sys.argv) != 2:
		print("Usage: python "+str(sys.argv[0])+" INPUTFILE")
		return 1

	fh = open(sys.argv[1], "r")
	lines = fh.readlines()
	fh.close()

	sol = simulate_drones(lines)
	print("Solution: "+str(sol))
	return 0

if __name__=="__main__":

	ret = solve()

	exit(ret)


```

this bullshit here displays this:

```
Our shit:
==============================
......2..1.
...........
1..........
.11........
.....1.....
...12......
.1....1....
==============================
```

so that means that the bug existed only in the rendering function and stuff... huh. Well, ok, so the bug is in the quadrant function...

That is because there is a fucking bug here:

```

if TEST:
	MAP_HEIGHT = 7
	MAP_WIDTH = 11

	MAP_WIDTH_MIDDLE = 5
	MAP_HEIGHT_MIDDLE = 4

else:
	MAP_HEIGHT = 103
	MAP_WIDTH = 101

	MAP_WIDTH_MIDDLE = 50
	MAP_HEIGHT_MIDDLE = 51

```

This is because in the TEST clause the `MAP_WIDTH_MIDDLE` should actually be 4 because zero. This is basically an off-by-one error.

After putting this:

```

	MAP_WIDTH_MIDDLE = 4
	MAP_HEIGHT_MIDDLE = 3
```

it now works. :D .

Does it work for the actual input?????

This code seems to work:

```

import re
import sys
import copy

TEST = False


def go_forward_in_time(p0, v, t): # This function returns the position after t timesteps.
	# Basically just p = p0 + v*t
	assert isinstance(t, int) # Timestep should be discrete integer.
	return (p0[0] + v[0]*t, p0[1] + v[1]*t)

if TEST:
	MAP_HEIGHT = 7
	MAP_WIDTH = 11

	MAP_WIDTH_MIDDLE = 4
	MAP_HEIGHT_MIDDLE = 3

else:
	MAP_HEIGHT = 103
	MAP_WIDTH = 101

	MAP_WIDTH_MIDDLE = 50
	MAP_HEIGHT_MIDDLE = 51

MIDDLE_CROSS = 0 # This is when we are in the boundary between quadrants. These do not count towards the total score.
BOTTOM_RIGHT = 1
BOTTOM_LEFT = 2
TOP_RIGHT = 3
TOP_LEFT = 4
TIMESTEPS = 100

def clamp_positions(positions):
	# So the position is basically just (x % width, y % height)
	return [(x[0] % MAP_WIDTH, x[1] % MAP_HEIGHT) for x in positions]

def quadrant(position): # Returns the quadrant thing. 0 means that it is in the middle cross which doesn't accumulate score.
	x = position[0]
	y = position[1]
	if x > MAP_WIDTH_MIDDLE: # On the right side.
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom right.
			return BOTTOM_RIGHT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top right
			return TOP_RIGHT
		else: # Boundary.
			return MIDDLE_CROSS
	elif x < MAP_WIDTH_MIDDLE:
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom left.
			return BOTTOM_LEFT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top left
			return TOP_LEFT
		else: # Boundary.
			return MIDDLE_CROSS
	else: # On the boundary
		return MIDDLE_CROSS
	assert False

def calc_safety_score(positions):
	quadrant_buckets = [0,0,0,0,0] # The first one is basically the cross boundary so it doesn't count towards the total.
	for pos in positions:
		q = quadrant(pos)
		assert q in list(range(5))
		quadrant_buckets[q] += 1
	#print("Our quadrant buckets:"+str(quadrant_buckets))
	assert sum(quadrant_buckets) <= len(positions) # Can not be more marks in the quadrant buckets than there are positions.

	return quadrant_buckets[1]*quadrant_buckets[2]*quadrant_buckets[3]*quadrant_buckets[4]

def render_matrix(matrix):
	#print(matrix)
	print("="*30)
	for line in matrix:
		for char in line:
			if char != 0:
				assert char < 10 # If more than ten then this fucks up the showing.
				print(str(char), end="")
			else:
				print(".", end="")
		print("\n", end="")
	print("="*30)
	return

def go_forward_and_clamp(drones, t):
	new_positions = [[go_forward_in_time(x[0], x[1], t), x[1]] for x in drones] # Go forward in time.
	clamped_positions = clamp_positions([x[0] for x in new_positions]) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.
	return clamped_positions


def show_positions(positions): # This takes in the clamped positions...
	show_matrix = [[0 for _ in range(MAP_WIDTH)] for _ in range(MAP_HEIGHT)]

	# Now just put all of the stuff.
	for pos in positions:
		show_matrix[pos[1]][pos[0]] += 1

	render_matrix(show_matrix)

	return

def render_drones(drones):
	# Shows all of the timesteps.
	new_positions = copy.deepcopy(drones)
	for i in range(TIMESTEPS):
		print("T = "+str(i))
		new_positions = [[go_forward_in_time(x[0], x[1], 1), x[1]] for x in new_positions] # Go forward in time.
		clamped_positions = clamp_positions([x[0] for x in new_positions]) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

		show_positions(clamped_positions)

	return

def simulate_drones(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])

	if TEST:
		render_drones(copy.deepcopy(drones))

	new_positions = [go_forward_in_time(x[0], x[1], TIMESTEPS) for x in drones] # Go forward in time.
	clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

	# Calculate safety score:
	if TEST:
		print("Our shit:")
		show_positions(clamped_positions)
	safety_score = calc_safety_score(clamped_positions)

	return safety_score

def solve() -> int:

	if len(sys.argv) != 2:
		print("Usage: python "+str(sys.argv[0])+" INPUTFILE")
		return 1

	fh = open(sys.argv[1], "r")
	lines = fh.readlines()
	fh.close()

	sol = simulate_drones(lines)
	print("Solution: "+str(sol))
	return 0

if __name__=="__main__":

	ret = solve()

	exit(ret)

```

And it seems to work! Great! Onto part2

## Part 2

Ok, so we just need to check for a christmas tree thing...

I am actually going to cheat a bit and see what the christmas tree looks like from the internet. Ok, so I think the tree is supposed to form when all of the drones are on distinct places.

Let's implement it!

Maybe something like this?

```


import re
import sys
import copy

TEST = False
SHOW = False
PART = 2


def go_forward_in_time(p0, v, t): # This function returns the position after t timesteps.
	# Basically just p = p0 + v*t
	assert isinstance(t, int) # Timestep should be discrete integer.
	return (p0[0] + v[0]*t, p0[1] + v[1]*t)

if TEST:
	MAP_HEIGHT = 7
	MAP_WIDTH = 11

	MAP_WIDTH_MIDDLE = 4
	MAP_HEIGHT_MIDDLE = 3

else:
	MAP_HEIGHT = 103
	MAP_WIDTH = 101

	MAP_WIDTH_MIDDLE = 50
	MAP_HEIGHT_MIDDLE = 51


MIDDLE_CROSS = 0 # This is when we are in the boundary between quadrants. These do not count towards the total score.
BOTTOM_RIGHT = 1
BOTTOM_LEFT = 2
TOP_RIGHT = 3
TOP_LEFT = 4
TIMESTEPS = 10000

def clamp_positions(positions):
	# So the position is basically just (x % width, y % height)
	return [(x[0] % MAP_WIDTH, x[1] % MAP_HEIGHT) for x in positions]

def quadrant(position): # Returns the quadrant thing. 0 means that it is in the middle cross which doesn't accumulate score.
	x = position[0]
	y = position[1]
	if x > MAP_WIDTH_MIDDLE: # On the right side.
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom right.
			return BOTTOM_RIGHT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top right
			return TOP_RIGHT
		else: # Boundary.
			return MIDDLE_CROSS
	elif x < MAP_WIDTH_MIDDLE:
		if y > MAP_HEIGHT_MIDDLE:
			# Bottom left.
			return BOTTOM_LEFT
		elif y < MAP_HEIGHT_MIDDLE: # We can not just use else because if we are in the middle, then that doesn't count.
			# Top left
			return TOP_LEFT
		else: # Boundary.
			return MIDDLE_CROSS
	else: # On the boundary
		return MIDDLE_CROSS
	assert False

def calc_safety_score(positions):
	quadrant_buckets = [0,0,0,0,0] # The first one is basically the cross boundary so it doesn't count towards the total.
	for pos in positions:
		q = quadrant(pos)
		assert q in list(range(5))
		quadrant_buckets[q] += 1
	#print("Our quadrant buckets:"+str(quadrant_buckets))
	assert sum(quadrant_buckets) <= len(positions) # Can not be more marks in the quadrant buckets than there are positions.

	return quadrant_buckets[1]*quadrant_buckets[2]*quadrant_buckets[3]*quadrant_buckets[4]

def render_matrix(matrix):
	#print(matrix)
	print("="*30)
	for line in matrix:
		for char in line:
			if char != 0:
				#assert char < 10 # If more than ten then this fucks up the showing.
				if char >= 10:
					# Just use X for greater than or equal to 10
					print("X", end="") # show_positions
				else:
					print(str(char), end="")
			else:
				print(".", end="")
		print("\n", end="")
	print("="*30)
	return

def go_forward_and_clamp(drones, t):
	new_positions = [[go_forward_in_time(x[0], x[1], t), x[1]] for x in drones] # Go forward in time.
	clamped_positions = clamp_positions([x[0] for x in new_positions]) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.
	return clamped_positions


def show_positions(positions): # This takes in the clamped positions...
	show_matrix = [[0 for _ in range(MAP_WIDTH)] for _ in range(MAP_HEIGHT)]

	# Now just put all of the stuff.
	for pos in positions:
		show_matrix[pos[1]][pos[0]] += 1

	render_matrix(show_matrix)

	return

def render_drones(drones):
	# Shows all of the timesteps.
	new_positions = copy.deepcopy(drones)
	for i in range(TIMESTEPS):
		print("T = "+str(i))
		new_positions = [[go_forward_in_time(x[0], x[1], 1), x[1]] for x in new_positions] # Go forward in time.
		clamped_positions = clamp_positions([x[0] for x in new_positions]) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

		show_positions(clamped_positions)

	return

def simulate_drones(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])

	if SHOW:
		render_drones(copy.deepcopy(drones))

	new_positions = [go_forward_in_time(x[0], x[1], TIMESTEPS) for x in drones] # Go forward in time.
	clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.

	# Calculate safety score:
	if TEST:
		print("Our shit:")
		show_positions(clamped_positions)
	safety_score = calc_safety_score(clamped_positions)

	return safety_score


def check_distinct(positions) -> bool:
	# Check if there are no overlapping drones. This may be indicative of a tree.

	checked = set()
	for pos in positions:
		if pos in checked:
			return False # Short circuit.
		else:
			checked.add(pos)
	return True



def simulate_drones_tree(drone_strings):
	# First parse

	drones = [] # A list of lists of tuples. each element is [(p0_x, p0_y), (vx, xy)]
	for string in drone_strings:
		p_str, v_str = string.split(" ")
		p_str = p_str[2:] # Cut out "p="
		v_str = v_str[2:] # Cut out "v="
		p_x, p_y = [int(x) for x in p_str.split(",")]
		v_x, v_y = [int(x) for x in v_str.split(",")]
		drones.append([(p_x, p_y), (v_x, v_y)])


	# Loop until we find a tree.

	# We assume that the tree is like as follows:

	#######
	#  X  #
	# XXX #
	#XXXXX#
	#  X  #
	#######

	time_count = 0 # Time steps.

	while True:

		new_positions = [go_forward_in_time(x[0], x[1], 1) for x in drones] # Go forward in time.
		clamped_positions = clamp_positions(new_positions) # This basically figures out where in the box we should actually be. Basically does modular arithmetic to figure out which space we actually loop back around to.
		time_count += 1 # We advanced once.

		drones = [(new_positions[i], drones[i][1]) for i in range(len(new_positions))]

		# Now check for the tree.

		if check_distinct(clamped_positions):
			print("This is distinct: ")
			show_positions(clamped_positions)
			print("Timestep: "+str(time_count))
			print("Is this a christmas tree?")
			input()
			#return time_count



	assert False



def solve() -> int:

	if len(sys.argv) != 2:
		print("Usage: python "+str(sys.argv[0])+" INPUTFILE")
		return 1

	fh = open(sys.argv[1], "r")
	lines = fh.readlines()
	fh.close()
	if PART==1:

		sol = simulate_drones(lines)
		print("Solution to part one: "+str(sol))
	elif PART==2:
		sol = simulate_drones_tree(lines)
		print("Solution to part two: "+str(sol))
	else:
		print("Invalid part: "+str(PART))
		return 1
	return 0

if __name__=="__main__":

	ret = solve()

	exit(ret)


```

that seems to work great... it shows the tree nicely. Let's see if there was a more efficient solution for part 2. I doubt it. Yeah I looked it up and there appears to be no better way of doing this really since you don't know the shape etc.. One way was to just look for ten or so occupied spaces in a row.



